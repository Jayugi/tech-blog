---
title: How not to write i18n calls
description: i18n calls: anti-patterns and best practices
tags: i18n, gettext
layout: article
---

At first glance, writing i18n calls (function calls that map a text id to its translations) seems trivial.
For example, for a German language user, the i18n call:

```javascript
i18n('Share')
```

simply retrieves the string *Teilen* from the following translation object (*gettext* .po file format):

```
msgid "Share"
msgstr "Teilen"
```

However, after analyzing the i18n calls in our applications, we discovered a set of anti-patterns that lead to low-quality translations and sometimes even posed a threat to the stability of our apps.

This blog post discusses these anti-patterns and explains how to avoid them.

I write this blog post with JavaScript and `gettext` (the arguably most popular software translation system) in mind, but some of the aspects I discuss apply independently of the exact technologies you use.

# What poorly written i18n calls do
Every time you write i18n calls, ask yourself if they do at least one of the following things.

If that's the case, refactor the calls to prevent the worst.

## They could break your app.
Yes, they *can*.
For example, if you wrap a template string (of whatever template your are using) into an i18n call.

Let's say your i18n call is:

```javascript
i18n('[You have {count} new notifications.]')
```

A translator forgets to add the closing `]`, your framework can't
evaluate the template and fails - at runtime.

Instead, first make the i18n call and then pass it to the template. Make sure you always use the same construct for *interpolation* (replacement).

```javascript
const message =
  i18n('You have __count__ new notifications.')
    .replace('__count__', '{count}');
const templateString = `[${message}]`;
```

## They have implications on your program logic.
Programmers sometimes abuse i18n calls for functionality that should clearly be part of the program logic.
This is more likely to happen if your i18n initiative starts with (multilingual) developers managing the translations into other languages themselves.

For example, developers might handle ID-to-name mappings via the translation framework.
This can lead to i18n calls like `i18n(category_type_id)`.
The i18n framework is supposed to look up the value of `category_type_id` and return different translations depending on the value.
It's hard to ensure that all values the variable can have are available as translation ids.
Instead, you should handle such ID-to-name mappings within your program logic. **Simply never pass variables to i18n calls**.

## They are heavily biased in favor of the language(s) you know.
Of course, you can't possibly know the details of all languages your app will be translated to, but you should at least consider the following two points:

* Sentence structure isn't the same in all languages. That's why you should never concatenate i18n calls like this:

  ```javascript
  i18n('You have') + ' ' __count__ + ' ' + i18n('new notifications.')
  ```

  Better use interpolation:

  ```javascript
  i18n('You have __count__ new notifications.')
  .replace('__count__', count)
  ```

* Many languages use more than just two [grammatical numbers](https://en.wikipedia.org/wiki/Grammatical_number). For example, a common additional number is the [dual](https://en.wikipedia.org/wiki/Dual_(grammatical_number)) , which applies only to the count distinction *two*.
For this, gettext provides generic [pluralization support](https://www.gnu.org/savannah-checkouts/gnu/gettext/manual/html_node/Plural-forms.html).

## They don't provide enough context for the translators.
Sometimes, you have one-word translation strings, for example for button labels. The naming conventions for button labels differ between languages.
In German, it's commonly the bare infinitive (without *zu* / *to*), while in Norwegian it's the imperative.
When they see the string *Share*, how can German translators know they should use the infinitive (*Teilen* as in *to share*) while the Norwegian translators know they should apply the imperative (*Del* as in *Share it!*)?

gettext provides `msgctxt` (message context) to address this problem. Together with the `message id`, you may pass a `message context` to the i18n call - like this:


```javascript
i18n('Share', 'button label')
```

In the .po file, the message will look like this:

```
msgctxt "button label"
msgid "Share"
msgstr "Teilen"
```
Now, the translators understand they need to apply their convention for button labels - in the example above, they choose to use the bare infinitive.
If the message id *Share* appears in another context, the translators can translate them differently.

## They require the translator to understand a complex markup language.
If you can avoid it, don't force your translators to use HTML or any other complex markup language.
It is, however, not always possible to completely get rid off all markup in an i18n call without sacrificing translate-ability.
That's why you should ideally support a light weight markup language like [Markdown](https://daringfireball.net/projects/markdown/syntax) in your i18n calls, for example using [this library](https://github.com/evilstreak/markdown-js).

Like this, the i18n call:

```javascript
i18n('You find more information about our <strong>licenses</strong> on our <a href="http://signavio.com">website</a>.')
```

becomes:

```javascript
markdown.toHTML(i18n('You find more information about our **licenses** on our [website](http://signavio.com).'))
```



# Conclusion
The anti-patterns above help you to avoid writing i18n calls that are clearly ugly hacks.
Concepts like **interpolation**, **message context** and **simplified markup** solve the most common problems your translators encounter.
Finally, to really ensure your translators can do their work, ensure they come to you to complain whenever they see an i18n message id that looks strange or is impossible to map to a decent translation.
